#!/usr/bin/env python

import admix
import fire
import pandas as pd
from typing import List
import subprocess
import dapgen
import numpy as np


def lanc(
    pfile: str,
    ref_pfile: str,
    sample_map: str,
    genetic_map: str,
    out_prefix: str,
    chrom: int = None,
    method: str = "rfmix",
    rfmix_path: str = "rfmix",
):
    """Estimate local ancestry from a sample vcf and reference vcf

    TODO: Contents in https://kangchenghou.github.io/admix-tools/en/main/prepare_data.html
        should be subsumed into this function
    Parameters
    ----------
    pfile : str
        PLINK2 pfile for admixed individuals
    ref_pfile : str
        PLINK2 pfile for reference individuals
    sample_map : str
        Text file with two column containing the population of individuals in ref_vcf
        the unique population will be used as reference ancestral population in
        estimation.
    genetic_map: str
        Text file with two column containing the genetic distance between two
    out_prefix: str
        Prefix for the output files.
    method : str, optional
        method for estimating local ancestry, by default "rfmix"

    """
    assert method in ["rfmix"], "Only rfmix is currently supported"

    # Step 1: use bcftools to align the sample and reference vcf
    align_ref_code = (
        f"""
        sample_vcf={sample_vcf}
        ref_vcf={ref_vcf}
        out_prefix={out_prefix}
    """
        + """

        tmp_dir=${out_prefix}.tmp/

        mkdir ${tmp_dir}

        if [[ ! -f ${sample_vcf}.tbi ]]; then
            echo "${sample_vcf} is not indexed. Please index it with tabix. Exiting..."
            exit
        fi

        # match reference panel
        bcftools isec -n =2 ${sample_vcf} ${ref_vcf} -p ${tmp_dir} -c none

        cat ${tmp_dir}/0000.vcf | bgzip -c >${tmp_dir}/sample.vcf.gz
        cat ${tmp_dir}/0001.vcf | bgzip -c >${tmp_dir}/ref.vcf.gz

        # remove chr
        for i in {1..22}; do
            echo "chr$i $i" >>${tmp_dir}/chr_name.txt
        done

        bcftools annotate --rename-chrs ${tmp_dir}/chr_name.txt ${tmp_dir}/sample.vcf.gz |
            bgzip >${out_prefix}.sample.vcf.gz
        bcftools annotate --rename-chrs ${tmp_dir}/chr_name.txt ${tmp_dir}/ref.vcf.gz |
            bgzip >${out_prefix}.ref.vcf.gz

        # clean up
        rm -rf ${tmp_dir}
    """
    )

    print(align_ref_code)
    subprocess.check_call(align_ref_code, shell=True)

    # Step 2: use rfmix to estimate local ancestry
    rfmix_code = (
        f"""
        sample_vcf={out_prefix}.sample.vcf.gz
        ref_vcf={out_prefix}.ref.vcf.gz
        sample_map={sample_map}
        genetic_map={genetic_map}
        chrom={chrom}
        out_prefix={out_prefix}
        rfmix={rfmix_path}
        """
        + """
        ${rfmix} \
            -f ${sample_vcf} \
            -r ${ref_vcf} \
            -m ${sample_map} \
            -g ${genetic_map} \
            --chromosome=${chrom} \
            -e 1 -n 5 \
            -o ${out_prefix}
        """
    )

    print(rfmix_code)
    subprocess.check_call(rfmix_code, shell=True)

    # Step 3: clean up
    clean_code = (
        f"""
        out_prefix={out_prefix}
        """
        + """
        rm -f ${out_prefix}.sample.vcf.gz
        rm -f ${out_prefix}.ref.vcf.gz
        """
    )

    print(clean_code)
    subprocess.check_call(clean_code, shell=True)


def pgen_attach_lanc(pgen: str, lanc: str, out: str = None):
    """
    Attach local ancestry to pgen file

    Parameters
    ----------
    pgen : str
        Path to the pgen file
    lanc : str
        Path to the local ancestry file
    out : str
        Path to the output zarr file, default to replacing .pgen to .lanc
    """

    if out is None:
        out = pgen.replace(".pgen", ".lanc")

    dset = dapgen.read_pfile(pgen, phase=True)
    dset = admix.data.assign_lanc(dset, lanc)
    dset.lanc.data.to_zarr(out)


# TODO: including logging functions
def vcf_to_dataset(
    vcf: str, lanc: str, out: str, region: str = None, samples: str = None
):
    """
    Convert a VCF file to a zarr file

    Parameters
    ----------
    vcf : str
        Path to the VCF file
    lanc : str
        Path to the local ancestry file
    out : str
        Path to the output zarr file
    region : str
        Region to extract from the VCF file
    samples : str
        Path to the samples file to extract from vcf files, one sample per line
    """
    if samples is not None:
        with open(samples) as f:
            sample_list = [l.strip() for l in f.readlines()]
    print(f"Loading {len(sample_list)} samples")

    print(f"Reading VCF file {vcf}...")
    dset = admix.io.read_vcf(vcf, region=region, samples=sample_list)
    print(f"Loaded VCF file shape: {dset.dims}")

    print(f"Reading and assigning local ancestry file {lanc}...")
    dset = admix.data.assign_lanc(dset, lanc)

    print(f"Saving file to {out}...")
    dset.chunk(chunks={"indiv": -1, "ploidy": -1, "snp": "auto"}).to_zarr(out, mode="w")


def merge_dataset(path_list: str, out: str):
    """Merge multiple dataset [in zarr format] into one dataset, assuming the individiduals
    are shared typically used for merging multiple datasets from different chromosomes.

    Parameters
    ----------
    path_list : List[str]
        path of a text file pointing to the list of paths
    out : str
        Path to the output zarr file
    """
    import xarray as xr

    dset_list = [xr.open_zarr(p) for p in path_list]

    dset = xr.concat(dset_list, dim="snp")

    dset = dset.chunk(chunks={"indiv": -1, "ploidy": -1, "snp": "auto"}).compute()
    dset.to_zarr(out, mode="w", safe_chunks=False)


def test():
    """
    Test the admix module
    """
    print("testing the admix module")


def prune(pfile: str, out: str, indep_pairwise_params: List = None):
    """Prune a pfile based on indep_pairwise_params

    Parameters
    ----------
    pfile : str
        pfile
    out : str
        out_prefix
    indep_pairwise_params : [type], optional
        if None, use the default [100 5 0.1]

    Returns
    -------
    out.[pgen|pvar|psam] will be created
    """
    if indep_pairwise_params is None:
        indep_pairwise_params = [100, 5, 0.1]

    admix.tools.plink2.prune(
        pfile=pfile,
        out_prefix=out,
        indep_pairwise_params=indep_pairwise_params,
    )


def pca(pfile: str, out: str, approx=False):
    """
    Perform PCA on a pgen file

    Parameters
    ----------
    pfile : str
        Path to the pgen file
    prune : bool
        Whether to prune the pfile using the default recipe
        --indep 200 5 1.15, --indep-pairwise 100 5 0.1
    out : str
        Path to the output file
    """
    admix.tools.plink2.pca(pfile=pfile, out_prefix=out, approx=approx)


def plot_pca(
    pfile: str,
    pca: str,
    out: str,
    label_col: str = None,
    x: str = "PC1",
    y: str = "PC2",
):
    """Plot PCA results to a file

    Parameters
    ----------
    pfile : str
        pfile
    label_col : str
        column in .psam file
    pca : str
        path to the pca file
    out : str
        path to the output file
    x : str
        x-axis (default PC1)
    y : str
        y-axis (default PC2)
    """
    import matplotlib.pyplot as plt
    import matplotlib as mpl

    mpl.style.use("classic")

    df_psam = dapgen.read_psam(pfile + ".psam")
    df_pca = pd.read_csv(pca, delim_whitespace=True, index_col=0)
    assert np.all(df_psam.index == df_pca.index)

    df_plot = pd.merge(df_psam, df_pca, left_index=True, right_index=True)

    fig, ax = plt.subplots(figsize=(2.5, 2.5))
    admix.plot.pca(df_plot, x=x, y=y, label_col=label_col)

    # make xticklabels and yticklabels smaller
    ax.tick_params(axis="x", labelsize=6)
    ax.tick_params(axis="y", labelsize=6)
    # make legend font smaller
    ax.legend(fontsize=8)
    plt.savefig(out, bbox_inches="tight", dpi=300)


if __name__ == "__main__":
    fire.Fire()